% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{kotex}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}

\usepackage{teamnote}

% \usepackage{fontspec}
% \setmonofont[Scale=0.9]{JetBrains Mono}

\teamnote{SNUPC 2025}{Kirby}{overnap}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% Make Pagebreak if you want.
% \pagebreak 


\section{Data Structure for RMQ}

% \Algorithm
% {Segment Tree w/ Lazy Propagation}
% {\texttt{update(1, 0, n-1, l, r, v)}}
% {$\mathcal{O}(\log{N})$}
% {cpp}
% {source/LazyPropagation.cpp}
% {overnap}

\Algorithm
{Sparse Table}
{RMQ l r: \texttt{min(lift[l][len], lift[r-(1<<len)+1][len])}}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/SparseTable.cpp}
{overnap}

% \Algorithm
% {Merge Sort Tree}
% {}
% {$\mathcal{O}(N\log{N})-\mathcal{O}(\log^2{N})$}
% {cpp}
% {source/MergeSortTree.cpp}
% {overnap}

% \Algorithm
% {Binray Search In Segment Tree}
% {}
% {$\mathcal{O}(\log{N})$}
% {cpp}
% {source/BinarySearchInSeg.cpp}
% {overnap}

\Algorithm
{Persistence Segment Tree}
{}
{$\mathcal{O}(\log^2{N})$}
{cpp}
{source/PersistenceSegmentTree.cpp}
{overnap}

% \Algorithm
% {Segment Tree Beats}
% {Note the potential function}
% {$\mathcal{O}(\log^2{N})$}
% {cpp}
% {source/SegmentTreeBeats.cpp}
% {overnap}

\Algorithm
{Fenwick RMQ}
{}
{Fast $\mathcal{O}(\log{N})$}
{cpp}
{source/FenwickRMQ.cpp}
{overnap}

% \Algorithm
% {Splay Tree w/ Lazy}
% {}
% {}
% {cpp}{source/SplayTree.cpp}
% {overnap}

\Algorithm
{Link/Cut Tree}
{}
{}
{cpp}{source/LinkCutTree.cpp}
{justicehui}


\section{Graph \& Flow}

% \Algorithm
% {BipartiteMatching}
% {Run dfs for all left nodes. The count of return value true equal to count of max possible matches.}
% {$\mathcal{O}(VE)$}
% {cpp}
% {source/BipartiteMatching.cpp}
% {sendol}

\Algorithm
{Hopcroft-Karp \& Kőnig's}
{Dinic's variant. Maximum Matching = Minimum Vertex Cover = S - Maximum Independence Set}
{$\mathcal{O}(\sqrt{V}E)$}
{cpp}
{source/HopcroftKarp.cpp}
{overnap}

% \Algorithm
% {Max Flow}
% {}
% {$\mathcal{O}(VE^2)$}
% {cpp}
% {source/EdmondsKarp.cpp}
% {overnap}

% \Algorithm
% {Min Cost Max Flow}
% {}
% {$\mathcal{O}(VEf)$}
% {cpp}
% {source/MCMF.cpp}
% {corncheese}

\Algorithm
{Dinic's}
{}
{$\mathcal{O}(V^2E)$, $\mathcal{O}(\min{(V^{2/3}E,E^{3/2})})$ on unit capacity}
{cpp}
{source/Dinic.cpp}
{overnap}

% \Algorithm
% {Dominator Tree}
% {}
% {$\mathcal{O}(N\log{N})$}
% {cpp}
% {source/DominatorTree.cpp}
% {justicehui}

\Algorithm
{Strongly Connected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/StronglyConnectedComponent.cpp}
{overnap}

\Algorithm
{Biconnected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/BiconnectedComponent.cpp}
{overnap}

% \Algorithm
% {Lowest Common Ancestor}
% {Query with the sparse table}
% {$\mathcal{O}(N\log{N})-\mathcal{O}(\log{N})$}
% {cpp}
% {source/LowestCommonAncestor.cpp}
% {overnap}

\Algorithm
{Heavy-Light Decomposition}
{Query with the ETT number and it's root node}
{$\mathcal{O}(N)-\mathcal{O}(\log{N})$}
{cpp}
{source/HeavyLightDecomposition.cpp}
{overnap}

\Algorithm
{Centroid Decomposition}
{cent[x] is the parent in centroid tree}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/CentroidDecomposition.cpp}
{overnap}


\section{Geometry}

\Algorithm
{Line intersection}
{Check the intersection of $(x_1, x_2)$ and $(y_1, y_2)$. It requires an additional condition when they are parallel}
{$\mathcal{O}(1)$}
{cpp}
{source/LineIntersection.cpp}
{penguin}

\Algorithm
{Graham Scan}
{}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/GrahamScan.cpp}
{penguin}

\Algorithm
{Rotating Calipers}
{Get the maximum distance of the convex hull}
{$\mathcal{O}(N)$}
{cpp}
{source/RotatingCalipers.cpp}
{penguin}

\Algorithm
{Bulldozer Trick}
{Traverse the entire sorting state of 2D points}
{$\mathcal{O}(N^2\log{N})$}
{cpp}
{source/Bulldozer.cpp}
{justicehui}

\Algorithm
{Point in Convex Polygon}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/penguin/PointInHull.cpp}
{penguin}

\Algorithm
{Line Hull Intersection}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/penguin/LineHullInter.cpp}
{penguin}


\section{Fast Fourier Transform}

\Algorithm
{Fast Fourier Transform}
{FFT and multiply polynomials}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastFourierTransform.cpp}
{DeobureoMinkyuParty}

\Algorithm
{Number Theoretic Transform and Kitamasa}
{FFT with integer - to get better accuracy}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/NumberTheoreticTransform.cpp}
{overnap}

\Algorithm
{Fast Walsh Hadamard Transform}
{XOR convolution}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastWalshHadamardTransform.cpp}
{overnap}

\section{String}

\Algorithm
{Knuth-Moris-Pratt}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/KnuthMorisPratt.cpp}
{overnap}

\Algorithm
{Rabin-Karp}
{The Rabin fingerprint for const-length hashing}
{$\mathcal{O}(N)$}
{cpp}
{source/RabinKarp.cpp}
{overnap}

\Algorithm
{Manacher}
{Longest radius of palindrome substring}
{$\mathcal{O}(N)$}
{cpp}
{source/Manacher.cpp}
{overnap}

\Algorithm
{Suffix Array and LCP Array}
{}
{$\mathcal{O}(N\log{N})-\mathcal{O}(N)$}
{cpp}
{source/SuffixArrayLCPArray.cpp}
{overnap}

\Algorithm
{Suffix Automaton}
{Suffix link corresponds to suffix tree of rev(S)}
{$\mathcal{O}(N)-\mathcal{O}(N)\text{ using hashmap or $\mathcal{O}(1)$ size array }$}
{cpp}
{source/SuffixAutomaton.cpp}
{overnap}

\Algorithm
{Aho-Corasick}
{}
{$\mathcal{O}(N+\sum{M})$}
{cpp}
{source/AhoCorasick.cpp}
{overnap}


\section{DP Optimization}

\Algorithm
{Convex Hull Trick w/ Stack}
{\texttt{dp[i] = min(dp[j] + b[j] * a[i]), b[j] >= b[j+1]}}
{$\mathcal{O}(N\log{N})-\mathcal{O}(N)\text{ where \texttt{a[i] <= a[i+1]} }$}
{cpp}
{source/ConvexHullTrick.cpp}
{overnap}

\Algorithm
{Convex Hull Trick w/ Li-Chao Tree}
{\texttt{update(l, r, 0, \{ a, b \})}}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/LiChaoTree.cpp}
{overnap}

\Algorithm
{Divide and Conquer Optimization}
{\texttt{dp[t][i] = min(dp[t-1][j] + c[j][i]), c is Monge}}
{$\mathcal{O}(KN\log{N})$}
{cpp}
{source/DivideAndConquerOptimization.cpp}
{overnap}

\Algorithm
{Monotone Queue Optimization}
{\texttt{dp[i] = min(dp[j] + c[j][i]), c is Monge, find cross}}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/MonotoneQueue.cpp}
{overnap}

\Algorithm
{Aliens Trick}
{\texttt{dp[t][i] = min(dp[t-1][j] + c[j+1][i]), c is Monge, find lambda w/ half bs}}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/Aliens.cpp}
{overnap}

\Algorithm
{Knuth Optimization}
{\texttt{dp[i] = min(dp[i][k] + dp[k][j]) + c[i][j]}, Monge, Monotonic}
{$\mathcal{O}(N^2)$}
{cpp}
{source/KnuthOptimization.cpp}
{overnap}

\Algorithm
{Slope Trick}
{Use priority queue, convex condition}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/SlopeTrick.cpp}
{overnap}

\Algorithm
{Sum Over Subsets}
{\texttt{dp[mask] = sum(A[i]), i is in mask}}
{$\mathcal{O}(N2^N)$}
{cpp}
{source/SumOverSubsets.cpp}
{gina65}


\section{Number Theory}

\Algorithm
{Modular Operator}
{For Fermat's little theorem and Pollard rho}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ModularOperator.cpp}
{overnap}

\Algorithm
{Modular Inverse in $\mathcal{O}(N)$}
{Get inverse of factorial}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/ModularInverse.cpp}
{overnap}

\Algorithm
{Extended Euclidean}
{get a and b as arguments and return the solution $(x, y)$ of equation $ax + by = \gcd(a, b)$.}
{$\mathcal{O}(\log{a} + \log{b})$}
{cpp}
{source/ExtendedEuclidean.cpp}
{sendol}

\Algorithm
{Floor Sum}
{sum of $\lfloor(ax + b)/c\rfloor$ where $x \in [0, n]$}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/FloorSum.cpp}
{overnap}

\Algorithm
{Miller-Rabin}
{Fast prime test for big integers}
{$\mathcal{O}(k\log{N})$}
{cpp}
{source/MillerRabin.cpp}
{overnap}

\Algorithm
{Lucy\_Hedgehog}
{Fast prime DP; runs within 4 secs where $N=10^{12}$}
{$\mathcal{O}(N^{3/4})$}
{cpp}
{source/LucyHedgehog.cpp}
{overnap}

\Algorithm
{Chinese Remainder Theorem}
{Solution for the system of linear congruence}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ChineseRemainderTheorem.cpp}
{overnap}

\Algorithm
{Pollard Rho}
{Factoring large numbers fast}
{$\mathcal{O}(N^{1/4})$}
{cpp}
{source/PollardRho.cpp}
{overnap}


\section{ETC}

\Algorithm
{Gaussian Elimination on $\mathbb{Z}^n_2$}
{}
{$\mathcal{O}(Nd^2/64)$}
{cpp}
{source/GaussianElimination.cpp}
{overnap}

\Algorithm
{Gaussian Elimination on $\mathbb{Z}^n_p$}
{Kirchhoff's, LGV, etc.}
{$\mathcal{O}(N^3)$}
{cpp}
{source/Determinant.cpp}
{overnap}

% \Algorithm
% {Parallel Binary Search}
% {}
% {$\mathcal{O}(N\log{N})$}
% {cpp}
% {source/ParallelBinarySearch.cpp}
% {overnap}

% \Algorithm
% {Hilbert Order}
% {For Mo's}
% {}
% {cpp}
% {source/HilbertOrder.cpp}
% {gepardo}

% \Algorithm
% {Ternary Search}
% {}
% {$\mathcal{O}(\log{N})$}
% {cpp}
% {source/TernarySearch.cpp}
% {overnap}

% \Algorithm
% {Berlekamp-Massey}
% {\texttt{get\_nth(\{1, 1, 2, 3, 5\}, n)}}
% {}
% {cpp}{source/BerlekampMassey.cpp}
% {koosaga}

\Algorithm{Useful Stuff}{}{}{}{}{}

% ref: https://github.com/green5555/Teamnote-archive
\begin{itemize}
    \item Catalan Number\\
          1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012,742900\\
          $C_n = binomial(n * 2, n) / (n + 1);$\\
          - 길이가 2n인 올바른 괄호 수식의 수\\
          - n + 1개의 리프를 가진 풀 바이너리 트리의 수\\
          - n + 2각형을 n개의 삼각형으로 나누는 방법의 수
    \item Burnside’s Lemma\\
          경우의 수를 세는데, 특정 transform operation(회전, 반사, ..) 해서 같은 경우들은 하나로 친다. 전체 경우의 수는? 각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다 (단, “아무것도 하지 않는다” 라는 operation도 있어야 함!) 전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)
    \item 알고리즘 게임\\
          - Nim Game의 해법 : 각 더미의 돌의 개수를 모두 XOR했을 때 0 이 아니면 첫번째, 0 이면 두번째 플레이어가 승리.\\
          - Grundy Number : 어떤 상황의 Grundy Number는, 가능한 다음 상황들의 Grundy Number를 모두 모은 다음, 그 집합에 포함 되지 않는 가장 작은 수가 현재 state의 Grundy Number가 된다. 만약 다음 state가 독립된 여러개의 state들로 나뉠 경우, 각각의 state의 Grundy Number의 XOR 합을 생각한다.\\
          - Subtraction Game : 한 번에 k 개까지의 돌만 가져갈 수 있는 경우, 각 더미의 돌의 개수를 k + 1로 나눈 나머지를 XOR 합하여 판단한다.\\
          - Index-k Nim : 한 번에 최대 k개의 더미를 골라 각각의 더미에서 아무렇게나 돌을 제거할 수 있을 때, 각 binary digit에 대하여 합을 k + 1로 나눈 나머지를 계산한다. 만약 이 나머지가 모든 digit에 대하여 0이라면 두번째, 하나라도 0이 아니라면 첫번째 플레이어가 승리.
    \item Pick’s Theorem\\
          격자점으로 구성된 simple polygon이 주어짐. I 는 polygon 내부의 격자점 수, B 는 polygon 선분 위 격자점 수, A는 polygon의 넓이라고 할 때, 다음과 같은 식이 성립한다. $A=I+B/2-1$
    \item 가장 가까운 두 점 : 분할정복으로 가까운 6개의 점만 확인
    \item 홀의 결혼 정리 : 이분그래프(L-R)에서, 모든 L을 매칭하는 필요충분 조건 = L에서 임의의 부분집합 S를 골랐을 때, 반드시 (S의 크기) $<=$ (S와 연결되어있는 모든 R의 크기)이다.
    \item 소수 : 10 007 , 10 009 , 10 111 , 31 567 , 70 001 , 1 000 003 , 1 000 033 , 4 000 037 , 99 999 989 , 999 999 937 , 1 000 000 007 , 1 000 000 009 , 9 999 999 967 , 99 999 999 977
    \item 소수 개수 : (1e5 이하 : 9592), (1e7 이하 : 664 579) , (1e9 이하 : 50 847 534)
    \item $10^{15}$ 이하의 정수 범위의 나눗셈 한번은 오차가 없다.
    \item N의 약수의 개수 = $O(N^{1/3})$, N의 약수의 합 = $O(NloglogN)$
    \item $\phi(mn) = \phi(m) \phi(n) , \phi(pr^n) = pr^n - pr^{n-1} , a^{\phi(n)} \equiv 1 \pmod{n} \ \text{if coprime}$
\end{itemize}

\begin{itemize}  % TODO: 점검
    \item Euler characteristic : v - e + f (면, 외부 포함) = 1 + c (컴포넌트)
    \item Euler's phi $\phi (n)=n\prod _{p\mid n}\left(1-{\frac {1}{p}}\right)$
    \item Lucas' Theorem $\binom{m}{n}=\prod\binom{m_i}{n_i} \pmod p$ $m_i$, $n_i$는 $p^i$의 계수
    \item 스케줄링에서 데드라인이 빠른 걸 쓰는게 이득. 늦은 스케줄이 안들어갈 때 가장 시간 소모가 큰 스케줄 1개를 제거하면 이득.
\end{itemize}

\Algorithm
{Template}
{}
{}
{cpp}
{source/Template.cpp}
{overnap}

\Algorithm{자주 쓰이는 문제 접근법}{}{}{}{}{}

% ref: https://github.com/ntopia/icpc-teamnote/blob/master/teamnote.tex
% ref: 알고리즘 문제 해결 전략
\begin{itemize}
    \item 비슷한 문제를 풀어본 적이 있던가?
    \item 단순한 방법에서 시작할 수 있을까? (brute force)
    \item 내가 문제를 푸는 과정을 수식화할 수 있을까? (예제를 직접 해결해보면서)
    \item 문제를 단순화할 수 없을까?
    \item 그림으로 그려볼 수 있을까?
    \item 수식으로 표현할 수 있을까?
    \item 문제를 분해할 수 있을까?
    \item 뒤에서부터 생각해서 문제를 풀 수 있을까?
    \item 순서를 강제할 수 있을까?
    \item 특정 형태의 답만을 고려할 수 있을까? (정규화)
\end{itemize}

\begin{itemize}
    \item 특수 조건을 꼭 활용
    \item 여사건으로 생각하기
    \item 게임이론 - 거울 전략 혹은 mex DP 연계
    \item 겁먹지 말고 경우 나누어 생각
    \item 해법에서 역순으로 가능한가?
    \item 딱 맞는 시간복잡도에 집착하지 말자
    \item 문제에 의미있는 작은 상수 이용
    \item 스몰투라지, 트라이, 해싱, 루트질 같은 트릭 생각
    \item 너무 추상화하기보단 풀려야 하는 방식으로 생각하기
    \item 잘못된 방법으로 파고들지 말고 버리자
    \item 제발 터널 비전에 빠지지 말자
    \item 헬프 콜은 적극적으로
    \item 혼자 멘탈 나가지 않기
\end{itemize}

\Algorithm{DP 최적화 접근}{}{}{}{}{}
\begin{itemize}
    \item C[i, j] = A[i] * B[j]이고 A, B가 단조증가, 단조감소이면 Monge
    \item l..r의 값들의 sum이나 min은 Monge

    \item 식 정리해서 일차(CHT) 혹은 비슷한(MQ) 함수를 발견, 구현 힘들면 Li-Chao
    \item $a <= b <= c <= d$에서 $A[a,c] + A[b,d] <= A[a,d] + A[b,c]$
    \item Monge 성질을 보이기 어려우면 $N^2$ 나이브 짜서 opt의 단조성을 확인하고 찍맞
    \item 식이 간단하거나 변수가 독립적이면 DP 테이블을 세그 위에 올려서 해결
    \item 침착하게 점화식부터 세우고 Monge인지 판별
    \item Monge에 집착하지 말고 단조성이나 볼록성만 보여도 됨
\end{itemize}

\Algorithm
{Fast I/O}
{}
{}
{cpp}{source/FastIO.cpp}
{justicehui}

\Algorithm
{Bitset Add Sub}
{}
{}
{cpp}
{source/BitsetAddSub.cpp}
{cgiosy}

\end{document}